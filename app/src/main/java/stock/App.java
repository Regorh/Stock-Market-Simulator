/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package stock;

import org.checkerframework.checker.units.qual.A;
import stock.controller.*;
import stock.model.Market;
import stock.model.Stock;
import stock.model.User;
import stock.view.Gui;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.util.ArrayList;
import java.util.Scanner;
public class App {
    public String getGreeting() {
        return "Hello World!";
    }

    public static void main(String[] args) {
        Gui mainscreeen = new Gui();
        System.out.println(new App().getGreeting());

        //this is reading the events text file and populating the possible events
        File file = new File("src/main/java/stock/controller/events.txt");
        ArrayList<String> events= new ArrayList<String>();
        //setting up a catch in case file loads wrong
        try {

            //read the file and parse each line, checking if it should be added to events
            BufferedReader br = new BufferedReader(new FileReader(file));
            String event;
            while((event = br.readLine()) != null){

                //must not start with "#" it also must be longer than 2 letters
                if (!(event.startsWith("#") || !(event.length() >= 2))) {
                    events.add(event);
                }
            }
        }
        catch (Exception e){
            System.out.println("FILE DOES NOT EXIST, EVENTS CANNOT LOAD");
        }

        //in case no events are read, we always have at least one event the "None event
        events.add("None");
        System.out.println(events);

        //creating of children
        EventRoller roller = new EventRoller(events);
        Algorithm algorithm = new Algorithm();
        User user = new User(algorithm.get_avg());


        boolean isDone = false;

        while(!isDone){
            //if( PUT USER SEC = 100, OR ILLNESS OR DEBT TOO HIGH HERE)
            // isDone == true
            String event = roller.roll_out();
            algorithm.next_day(event);
            user.process_event(event);


        }




    }
}
